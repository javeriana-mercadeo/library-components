// ==========================================
// FUNCIONES ACTUALIZADAS PARA GENERAR RGB
// ==========================================
@use 'sass:color';
@use 'sass:map';
@use 'sass:list';
@use 'sass:math';
@use 'sass:meta';
@use 'sass:string';
@use 'variables' as *;

// MEDIDAS RELATIVAS
// ----------------------------------------------------
// Función para convertir píxeles a rem
@function rem($pixels) {
  @return #{calc($pixels / $base-font-size)}rem;
}

// CONVERSIÓN DE COLORES
// ----------------------------------------------------
// Función para convertir un color a formato RGB sin parentesis
@function color-to-rgb($color) {
  @return #{color.channel($color, 'red', $space: rgb)}, #{color.channel($color, 'green', $space: rgb)},
    #{color.channel($color, 'blue', $space: rgb)};
}

// Función para convertir un color HSL a RGB completo
@function hsl-to-rgb($color) {
  @return rgb(
    round(color.channel($color, 'red', $space: rgb)),
    round(color.channel($color, 'green', $space: rgb)),
    round(color.channel($color, 'blue', $space: rgb))
  );
}

// INVERSIÓN DE COLORES
// ----------------------------------------------------
// Función para invertir solo los valores de un mapa
@function invert-color-map($input-map) {
  // Validación de entrada
  @if $input-map == null {
    @error "invert-color-map(): $input-map no puede ser null";
  }
  @if meta.type-of($input-map) != 'map' {
    @error "invert-color-map(): $input-map debe ser un mapa, recibido: #{meta.type-of($input-map)}";
  }

  $reversed-map: ();

  // 1. GUARDAR el valor de la clave vacía (si existe)
  $empty-key-value: null;
  @if map.has-key($input-map, '') {
    $empty-key-value: map.get($input-map, '');
  }

  // 2. CREAR listas de claves y valores EXCLUYENDO la clave vacía
  $filtered-keys: ();
  $filtered-values: ();

  @each $key, $value in $input-map {
    @if $key != '' {
      $filtered-keys: list.append($filtered-keys, $key);
      $filtered-values: list.append($filtered-values, $value);
    }
  }

  // 3. INVERTIR solo los valores filtrados
  $reversed-values: ();
  @for $i from list.length($filtered-values) through 1 {
    $reversed-values: list.append($reversed-values, list.nth($filtered-values, $i));
  }

  // 4. CREAR el mapa invertido con las claves originales y valores invertidos
  @for $j from 1 through list.length($filtered-keys) {
    $key: list.nth($filtered-keys, $j);
    $value: list.nth($reversed-values, $j);
    $reversed-map: map.set($reversed-map, $key, $value);
  }

  // 5. RESTAURAR la clave vacía con su valor original
  @if $empty-key-value != null {
    $reversed-map: map.set($reversed-map, '', $empty-key-value);
  }

  @return $reversed-map;
}

// ESCALAS DE COLORES CON RGB
// ----------------------------------------------------
// Generador de escala de colores que incluye valores RGB para TODOS los colores
@function generate-color-scale($base-color, $inverted: false) {
  $hue: color.channel($base-color, 'hue', $space: hsl);
  $saturation: color.channel($base-color, 'saturation', $space: hsl);
  $color-scale: ();

  // Color base
  $color-scale: map.set($color-scale, '', $base-color);
  $color-scale: map.set($color-scale, 'rgb', color-to-rgb($base-color));

  @if $inverted {
    $lightness-steps: invert-color-map($lightness-steps);
    @each $step, $light in $lightness-steps {
      $hsl-color: hsl($hue, $saturation, $light);
      $color-value: hsl-to-rgb($hsl-color);
      $color-scale: map.set($color-scale, $step, $color-value);
      $color-scale: map.set($color-scale, '#{$step}-rgb', color-to-rgb($color-value));
    }
  } @else {
    @each $step, $light in $lightness-steps {
      $hsl-color: hsl($hue, $saturation, $light);
      $color-value: hsl-to-rgb($hsl-color);
      $color-scale: map.set($color-scale, $step, $color-value);
      $color-scale: map.set($color-scale, '#{$step}-rgb', color-to-rgb($color-value));
    }
  }

  @return $color-scale;
}

// GENERAR MAPA CON RGB (UNIVERSAL)
// ----------------------------------------------------
// Función universal que añade variables RGB a cualquier mapa de colores
@function add-rgb-to-color-map($color-map) {
  $map-with-rgb: ();

  @each $variant, $color in $color-map {
    // Agregar el color original
    $map-with-rgb: map.set($map-with-rgb, $variant, $color);

    // Agregar la versión RGB
    @if $variant != '' {
      $map-with-rgb: map.set($map-with-rgb, '#{$variant}-rgb', color-to-rgb($color));
    } @else {
      $map-with-rgb: map.set($map-with-rgb, 'rgb', color-to-rgb($color));
    }
  }

  @return $map-with-rgb;
}

// EXTRACCIÓN DE COLORES
// ----------------------------------------------------
// Extractor de color de la base de colores
@function extract-color($color-name) {
  @return map.get($color-base, $color-name);
}

// LUMINANCIA
// ----------------------------------------------------
// Función para calcular la luminancia de un color
@function luminance($color) {
  $r: math.div(color.channel($color, 'red', $space: rgb), 255);
  $g: math.div(color.channel($color, 'green', $space: rgb), 255);
  $b: math.div(color.channel($color, 'blue', $space: rgb), 255);

  $values: ($r, $g, $b);
  $adjusted: ();

  @each $value in $values {
    $adjusted: list.append($adjusted, if($value <= 0.03928, math.div($value, 12.92), math.pow(math.div($value + 0.055, 1.055), 2.4)));
  }

  @return list.nth($adjusted, 1) * 0.2126 + list.nth($adjusted, 2) * 0.7152 + list.nth($adjusted, 3) * 0.0722;
}

// CONTRASTE DE TEXTO
// ----------------------------------------------------
// Función para determinar si el texto debe ser blanco o negro
@function text-contrast($background-color) {
  @if meta.type-of($background-color) != 'color' {
    @error "El valor `#{$background-color}` no es un color válido.";
  }

  $bg-luminance: luminance($background-color);

  @if $bg-luminance > 0.55 {
    @return var(--neutral-100);
  } @else {
    @return var(--neutral-1000);
  }
}

@function text-contrast-byVarName($background-color) {
  @if meta.type-of($background-color) != 'color' {
    // Determinar si el tema es oscuro o claro basado en el nombre de la variable
    @if string.index($background-color, '--neutral-') and string.index($background-color, '-100') {
      @return var(--neutral-1000);
    } @else if string.index($background-color, '-500') or string.index($background-color, '-800') {
      @return var(--neutral-100);
    } @else if string.index($background-color, '') {
      @return var(--neutral-100);
    } @else {
      @return var(--neutral-1000);
    }
  }

  // Para valores de color reales, usa el cálculo de luminancia
  $bg-luminance: luminance($background-color);

  @if $bg-luminance > 0.45 {
    @return var(--neutral-100);
  } @else {
    @return var(--neutral-1000);
  }
}

// FUNCIÓN PARA ACCEDER A LOS COLORES SEMÁNTICOS
// ------------------------------------------
// Permite usar los colores semánticos de forma programática
@function semantic-color($name) {
  @if map.has-key($semantic-colors, $name) {
    @return map.get($semantic-colors, $name);
  }

  @error "Color semántico '#{$name}' no encontrado en $semantic-colors";
}

// FUNCIÓN PARA MERGE PROFUNDO
// ------------------------------------------
@function deep-merge($map1, $map2) {
  $result: $map1;

  @each $key, $value in $map2 {
    $existing: map.get($result, $key);

    $new-value: if(meta.type-of($existing) == 'map' and meta.type-of($value) == 'map', deep-merge($existing, $value), $value);

    $result: map.merge(
      $result,
      (
        $key: $new-value
      )
    );
  }

  @return $result;
}